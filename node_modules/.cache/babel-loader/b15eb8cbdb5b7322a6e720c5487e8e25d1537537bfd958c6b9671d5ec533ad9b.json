{"ast":null,"code":"'use strict';\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Csv2Json = void 0;\nconst doc_path_1 = require(\"doc-path\");\nconst constants_1 = require(\"./constants\");\nconst utils = __importStar(require(\"./utils\"));\nconst Csv2Json = function (options) {\n  const escapedWrapDelimiterRegex = new RegExp(options.delimiter.wrap + options.delimiter.wrap, 'g'),\n    excelBOMRegex = new RegExp('^' + constants_1.excelBOM),\n    valueParserFn = options.parseValue && typeof options.parseValue === 'function' ? options.parseValue : JSON.parse;\n  /**\n   * Trims the header key, if specified by the user via the provided options\n   */\n  function processHeaderKey(headerKey) {\n    headerKey = removeWrapDelimitersFromValue(headerKey);\n    if (options.trimHeaderFields) {\n      return headerKey.split('.').map(component => component.trim()).join('.');\n    }\n    return headerKey;\n  }\n  /**\n   * Generate the JSON heading from the CSV\n   */\n  function retrieveHeading(lines) {\n    let headerFields = [];\n    if (options.headerFields) {\n      headerFields = options.headerFields.map((headerField, index) => ({\n        value: processHeaderKey(headerField),\n        index\n      }));\n    } else {\n      // Generate and return the heading keys\n      const headerRow = lines[0];\n      headerFields = headerRow.map((headerKey, index) => ({\n        value: processHeaderKey(headerKey),\n        index\n      }));\n      // If the user provided keys, filter the generated keys to just the user provided keys so we also have the key index\n      if (options.keys) {\n        const keys = options.keys; // TypeScript type checking work around to get it to recognize the option is not undefined\n        headerFields = headerFields.filter(headerKey => keys.includes(headerKey.value));\n      }\n    }\n    return {\n      lines,\n      headerFields,\n      recordLines: []\n    };\n  }\n  /**\n   * Removes the Excel BOM value, if specified by the options object\n   */\n  function stripExcelBOM(csv) {\n    if (options.excelBOM) {\n      return csv.replace(excelBOMRegex, '');\n    }\n    return csv;\n  }\n  /**\n   * Helper function that splits a line so that we can handle wrapped fields\n   */\n  function splitLines(csv) {\n    // Parse out the line...\n    const lines = [],\n      lastCharacterIndex = csv.length - 1,\n      eolDelimiterLength = options.delimiter.eol.length,\n      stateVariables = {\n        insideWrapDelimiter: false,\n        parsingValue: true,\n        justParsedDoubleQuote: false,\n        startIndex: 0\n      };\n    let splitLine = [],\n      character,\n      charBefore,\n      charAfter,\n      nextNChar,\n      index = 0;\n    // Loop through each character in the line to identify where to split the values\n    while (index < csv.length) {\n      // Current character\n      character = csv[index];\n      // Previous character\n      charBefore = index ? csv[index - 1] : '';\n      // Next character\n      charAfter = index < lastCharacterIndex ? csv[index + 1] : '';\n      // Next n characters, including the current character, where n = length(EOL delimiter)\n      // This allows for the checking of an EOL delimiter when if it is more than a single character (eg. '\\r\\n')\n      nextNChar = utils.getNCharacters(csv, index, eolDelimiterLength);\n      if ((nextNChar === options.delimiter.eol && !stateVariables.insideWrapDelimiter || index === lastCharacterIndex) && charBefore === options.delimiter.field) {\n        // If we reached an EOL delimiter or the end of the csv and the previous character is a field delimiter...\n        // If the start index is the current index (and since the previous character is a comma),\n        //   then the value being parsed is an empty value accordingly, add an empty string\n        if (nextNChar === options.delimiter.eol && stateVariables.startIndex === index) {\n          splitLine.push('');\n        } else if (character === options.delimiter.field) {\n          // If we reached the end of the CSV, there's no new line, and the current character is a comma\n          // then add an empty string for the current value\n          splitLine.push('');\n        } else {\n          // Otherwise, there's a valid value, and the start index isn't the current index, grab the whole value\n          splitLine.push(csv.substr(stateVariables.startIndex));\n        }\n        // Since the last character is a comma, there's still an additional implied field value trailing the comma.\n        //   Since this value is empty, we push an extra empty value\n        splitLine.push('');\n        // Finally, push the split line values into the lines array and clear the split line\n        lines.push(splitLine);\n        splitLine = [];\n        stateVariables.startIndex = index + eolDelimiterLength;\n        stateVariables.parsingValue = true;\n        stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;\n      } else if (index === lastCharacterIndex && character === options.delimiter.field) {\n        // If we reach the end of the CSV and the current character is a field delimiter\n        // Parse the previously seen value and add it to the line\n        const parsedValue = csv.substring(stateVariables.startIndex, index);\n        splitLine.push(parsedValue);\n        // Then add an empty string to the line since the last character being a field delimiter indicates an empty field\n        splitLine.push('');\n        lines.push(splitLine);\n      } else if (index === lastCharacterIndex || nextNChar === options.delimiter.eol && (\n      // if we aren't inside wrap delimiters or if we are but the character before was a wrap delimiter and we didn't just see two\n      !stateVariables.insideWrapDelimiter || stateVariables.insideWrapDelimiter && charBefore === options.delimiter.wrap && !stateVariables.justParsedDoubleQuote)) {\n        // Otherwise if we reached the end of the line or csv (and current character is not a field delimiter)\n        const toIndex = index !== lastCharacterIndex || charBefore === options.delimiter.wrap ? index : undefined;\n        // Retrieve the remaining value and add it to the split line list of values\n        splitLine.push(csv.substring(stateVariables.startIndex, toIndex));\n        // Finally, push the split line values into the lines array and clear the split line\n        lines.push(splitLine);\n        splitLine = [];\n        stateVariables.startIndex = index + eolDelimiterLength;\n        stateVariables.parsingValue = true;\n        stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;\n      } else if (character === options.delimiter.wrap && charBefore === options.delimiter.field && !stateVariables.insideWrapDelimiter && !stateVariables.parsingValue) {\n        // If we reached a wrap delimiter after a comma and we aren't inside a wrap delimiter\n        stateVariables.startIndex = index;\n        stateVariables.insideWrapDelimiter = true;\n        stateVariables.parsingValue = true;\n        // If the next character(s) are an EOL delimiter, then skip them so we don't parse what we've seen as another value\n        if (utils.getNCharacters(csv, index + 1, eolDelimiterLength) === options.delimiter.eol) {\n          index += options.delimiter.eol.length + 1; // Skip past EOL\n        }\n      } else if ((charBefore !== options.delimiter.wrap || stateVariables.justParsedDoubleQuote && charBefore === options.delimiter.wrap) && character === options.delimiter.wrap && utils.getNCharacters(csv, index + 1, eolDelimiterLength) === options.delimiter.eol) {\n        // If we reach a wrap which is not preceded by a wrap delim and the next character is an EOL delim (ie. *\"\\n)\n        stateVariables.insideWrapDelimiter = false;\n        stateVariables.parsingValue = false;\n        // Next iteration will substring, add the value to the line, and push the line onto the array of lines\n      } else if (character === options.delimiter.wrap && (index === 0 || utils.getNCharacters(csv, index - eolDelimiterLength, eolDelimiterLength) === options.delimiter.eol && !stateVariables.insideWrapDelimiter)) {\n        // If the line starts with a wrap delimiter (ie. \"*)\n        stateVariables.insideWrapDelimiter = true;\n        stateVariables.parsingValue = true;\n        stateVariables.startIndex = index;\n      } else if (character === options.delimiter.wrap && charAfter === options.delimiter.field) {\n        // If we reached a wrap delimiter with a field delimiter after it (ie. *\",)\n        splitLine.push(csv.substring(stateVariables.startIndex, index + 1));\n        stateVariables.startIndex = index + 2; // next value starts after the field delimiter\n        stateVariables.insideWrapDelimiter = false;\n        stateVariables.parsingValue = false;\n      } else if (character === options.delimiter.wrap && charBefore === options.delimiter.field && !stateVariables.insideWrapDelimiter && stateVariables.parsingValue) {\n        // If we reached a wrap delimiter with a field delimiter after it (ie. ,\"*)\n        splitLine.push(csv.substring(stateVariables.startIndex, index - 1));\n        stateVariables.insideWrapDelimiter = true;\n        stateVariables.parsingValue = true;\n        stateVariables.startIndex = index;\n      } else if (character === options.delimiter.wrap && charAfter === options.delimiter.wrap && index !== stateVariables.startIndex) {\n        // If we run into an escaped quote (ie. \"\") skip past the second quote\n        index += 2;\n        stateVariables.justParsedDoubleQuote = true;\n        continue;\n      } else if (character === options.delimiter.field && charBefore !== options.delimiter.wrap && charAfter !== options.delimiter.wrap && !stateVariables.insideWrapDelimiter && stateVariables.parsingValue) {\n        // If we reached a field delimiter and are not inside the wrap delimiters (ie. *,*)\n        splitLine.push(csv.substring(stateVariables.startIndex, index));\n        stateVariables.startIndex = index + 1;\n      } else if (character === options.delimiter.field && charBefore === options.delimiter.wrap && charAfter !== options.delimiter.wrap && !stateVariables.parsingValue) {\n        // If we reached a field delimiter, the previous character was a wrap delimiter, and the\n        //   next character is not a wrap delimiter (ie. \",*)\n        stateVariables.insideWrapDelimiter = false;\n        stateVariables.parsingValue = true;\n        stateVariables.startIndex = index + 1;\n      }\n      // Otherwise increment to the next character\n      index++;\n      // Reset the double quote state variable\n      stateVariables.justParsedDoubleQuote = false;\n    }\n    return lines;\n  }\n  /**\n   * Retrieves the record lines from the split CSV lines and sets it on the params object\n   */\n  function retrieveRecordLines(params) {\n    if (options.headerFields) {\n      // This option is passed for instances where the CSV has no header line\n      params.recordLines = params.lines;\n    } else {\n      // All lines except for the header line\n      params.recordLines = params.lines.splice(1);\n    }\n    return params;\n  }\n  /**\n   * Retrieves the value for the record from the line at the provided key.\n   */\n  function retrieveRecordValueFromLine(headerField, line) {\n    // If there is a value at the key's index, use it; otherwise, null\n    const value = line[headerField.index];\n    // Perform any necessary value conversions on the record value\n    return processRecordValue(value);\n  }\n  /**\n   * Processes the record's value by parsing the data to ensure the CSV is\n   * converted to the JSON that created it.\n   */\n  function processRecordValue(fieldValue) {\n    // If the value is an array representation, convert it\n    const parsedJson = parseValue(fieldValue);\n    // If parsedJson is anything aside from an error, then we want to use the parsed value\n    // This allows us to interpret values like 'null' --> null, 'false' --> false\n    if (!utils.isError(parsedJson) && !utils.isInvalid(parsedJson)) {\n      return parsedJson;\n    } else if (fieldValue === 'undefined') {\n      return undefined;\n    }\n    return fieldValue;\n  }\n  /**\n   * Trims the record value, if specified by the user via the options object\n   */\n  function trimRecordValue(fieldValue) {\n    if (options.trimFieldValues && fieldValue !== null) {\n      return fieldValue.trim();\n    }\n    return fieldValue;\n  }\n  /**\n   * Create a JSON document with the given keys (designated by the CSV header)\n   *   and the values (from the given line)\n   * @returns {Object} created json document\n   */\n  function createDocument(headerFields, line) {\n    // Reduce the keys into a JSON document representing the given line\n    return headerFields.reduce((document, headerField) => {\n      // If there is a value at the key's index in the line, set the value; otherwise null\n      const value = retrieveRecordValueFromLine(headerField, line);\n      try {\n        // Otherwise add the key and value to the document\n        return (0, doc_path_1.setPath)(document, headerField.value, value);\n      } catch (error) {\n        // Catch any errors where key paths are null or '' and continue\n        return document;\n      }\n    }, {});\n  }\n  /**\n   * Removes the outermost wrap delimiters from a value, if they are present\n   * Otherwise, the non-wrapped value is returned as is\n   */\n  function removeWrapDelimitersFromValue(fieldValue) {\n    const firstChar = fieldValue[0],\n      lastIndex = fieldValue.length - 1,\n      lastChar = fieldValue[lastIndex];\n    // If the field starts and ends with a wrap delimiter\n    if (firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap) {\n      return fieldValue.substr(1, lastIndex - 1);\n    }\n    return fieldValue;\n  }\n  /**\n   * Unescapes wrap delimiters by replacing duplicates with a single (eg. \"\" -> \")\n   * This is done in order to parse RFC 4180 compliant CSV back to JSON\n   */\n  function unescapeWrapDelimiterInField(fieldValue) {\n    return fieldValue.replace(escapedWrapDelimiterRegex, options.delimiter.wrap);\n  }\n  /**\n   * Main helper function to convert the CSV to the JSON document array\n   */\n  function transformRecordLines(params) {\n    // For each line, create the document and add it to the array of documents\n    return params.recordLines.reduce((generatedJsonObjects, line) => {\n      line = line.map(fieldValue => {\n        // Perform the necessary operations on each line\n        fieldValue = removeWrapDelimitersFromValue(fieldValue);\n        fieldValue = unescapeWrapDelimiterInField(fieldValue);\n        fieldValue = trimRecordValue(fieldValue);\n        return fieldValue;\n      });\n      const generatedDocument = createDocument(params.headerFields, line);\n      return generatedJsonObjects.concat(generatedDocument);\n    }, []);\n  }\n  /**\n   * Attempts to parse the provided value. If it is not parsable, then an error is returned\n   */\n  function parseValue(value) {\n    try {\n      if (utils.isStringRepresentation(value, options) && !utils.isDateRepresentation(value)) {\n        return value;\n      }\n      const parsedJson = valueParserFn(value);\n      // If the parsed value is an array, then we also need to trim record values, if specified\n      if (Array.isArray(parsedJson)) {\n        return parsedJson.map(trimRecordValue);\n      }\n      return parsedJson;\n    } catch (err) {\n      return err;\n    }\n  }\n  /**\n   * Internally exported csv2json function\n   */\n  function convert(data) {\n    // Split the CSV into lines using the specified EOL option\n    const stripped = stripExcelBOM(data);\n    const split = splitLines(stripped);\n    const heading = retrieveHeading(split); // Retrieve the headings from the CSV, unless the user specified the keys\n    const lines = retrieveRecordLines(heading); // Retrieve the record lines from the CSV\n    return transformRecordLines(lines); // Retrieve the JSON document array\n  }\n  return {\n    convert\n  };\n};\nexports.Csv2Json = Csv2Json;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","Csv2Json","doc_path_1","require","constants_1","utils","options","escapedWrapDelimiterRegex","RegExp","delimiter","wrap","excelBOMRegex","excelBOM","valueParserFn","parseValue","JSON","parse","processHeaderKey","headerKey","removeWrapDelimitersFromValue","trimHeaderFields","split","map","component","trim","join","retrieveHeading","lines","headerFields","headerField","index","headerRow","keys","filter","includes","recordLines","stripExcelBOM","csv","replace","splitLines","lastCharacterIndex","length","eolDelimiterLength","eol","stateVariables","insideWrapDelimiter","parsingValue","justParsedDoubleQuote","startIndex","splitLine","character","charBefore","charAfter","nextNChar","getNCharacters","field","push","substr","parsedValue","substring","toIndex","retrieveRecordLines","params","splice","retrieveRecordValueFromLine","line","processRecordValue","fieldValue","parsedJson","isError","isInvalid","trimRecordValue","trimFieldValues","createDocument","reduce","document","setPath","error","firstChar","lastIndex","lastChar","unescapeWrapDelimiterInField","transformRecordLines","generatedJsonObjects","generatedDocument","concat","isStringRepresentation","isDateRepresentation","Array","isArray","err","convert","data","stripped","heading"],"sources":["C:/Users/David/Desktop/Websites/stocks/frontend/node_modules/json-2-csv/lib/csv2json.js"],"sourcesContent":["'use strict';\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Csv2Json = void 0;\nconst doc_path_1 = require(\"doc-path\");\nconst constants_1 = require(\"./constants\");\nconst utils = __importStar(require(\"./utils\"));\nconst Csv2Json = function (options) {\n    const escapedWrapDelimiterRegex = new RegExp(options.delimiter.wrap + options.delimiter.wrap, 'g'), excelBOMRegex = new RegExp('^' + constants_1.excelBOM), valueParserFn = options.parseValue && typeof options.parseValue === 'function' ? options.parseValue : JSON.parse;\n    /**\n     * Trims the header key, if specified by the user via the provided options\n     */\n    function processHeaderKey(headerKey) {\n        headerKey = removeWrapDelimitersFromValue(headerKey);\n        if (options.trimHeaderFields) {\n            return headerKey.split('.')\n                .map((component) => component.trim())\n                .join('.');\n        }\n        return headerKey;\n    }\n    /**\n     * Generate the JSON heading from the CSV\n     */\n    function retrieveHeading(lines) {\n        let headerFields = [];\n        if (options.headerFields) {\n            headerFields = options.headerFields.map((headerField, index) => ({\n                value: processHeaderKey(headerField),\n                index\n            }));\n        }\n        else {\n            // Generate and return the heading keys\n            const headerRow = lines[0];\n            headerFields = headerRow.map((headerKey, index) => ({\n                value: processHeaderKey(headerKey),\n                index\n            }));\n            // If the user provided keys, filter the generated keys to just the user provided keys so we also have the key index\n            if (options.keys) {\n                const keys = options.keys; // TypeScript type checking work around to get it to recognize the option is not undefined\n                headerFields = headerFields.filter((headerKey) => keys.includes(headerKey.value));\n            }\n        }\n        return {\n            lines,\n            headerFields,\n            recordLines: [],\n        };\n    }\n    /**\n     * Removes the Excel BOM value, if specified by the options object\n     */\n    function stripExcelBOM(csv) {\n        if (options.excelBOM) {\n            return csv.replace(excelBOMRegex, '');\n        }\n        return csv;\n    }\n    /**\n     * Helper function that splits a line so that we can handle wrapped fields\n     */\n    function splitLines(csv) {\n        // Parse out the line...\n        const lines = [], lastCharacterIndex = csv.length - 1, eolDelimiterLength = options.delimiter.eol.length, stateVariables = {\n            insideWrapDelimiter: false,\n            parsingValue: true,\n            justParsedDoubleQuote: false,\n            startIndex: 0\n        };\n        let splitLine = [], character, charBefore, charAfter, nextNChar, index = 0;\n        // Loop through each character in the line to identify where to split the values\n        while (index < csv.length) {\n            // Current character\n            character = csv[index];\n            // Previous character\n            charBefore = index ? csv[index - 1] : '';\n            // Next character\n            charAfter = index < lastCharacterIndex ? csv[index + 1] : '';\n            // Next n characters, including the current character, where n = length(EOL delimiter)\n            // This allows for the checking of an EOL delimiter when if it is more than a single character (eg. '\\r\\n')\n            nextNChar = utils.getNCharacters(csv, index, eolDelimiterLength);\n            if ((nextNChar === options.delimiter.eol && !stateVariables.insideWrapDelimiter ||\n                index === lastCharacterIndex) && charBefore === options.delimiter.field) {\n                // If we reached an EOL delimiter or the end of the csv and the previous character is a field delimiter...\n                // If the start index is the current index (and since the previous character is a comma),\n                //   then the value being parsed is an empty value accordingly, add an empty string\n                if (nextNChar === options.delimiter.eol && stateVariables.startIndex === index) {\n                    splitLine.push('');\n                }\n                else if (character === options.delimiter.field) {\n                    // If we reached the end of the CSV, there's no new line, and the current character is a comma\n                    // then add an empty string for the current value\n                    splitLine.push('');\n                }\n                else {\n                    // Otherwise, there's a valid value, and the start index isn't the current index, grab the whole value\n                    splitLine.push(csv.substr(stateVariables.startIndex));\n                }\n                // Since the last character is a comma, there's still an additional implied field value trailing the comma.\n                //   Since this value is empty, we push an extra empty value\n                splitLine.push('');\n                // Finally, push the split line values into the lines array and clear the split line\n                lines.push(splitLine);\n                splitLine = [];\n                stateVariables.startIndex = index + eolDelimiterLength;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;\n            }\n            else if (index === lastCharacterIndex && character === options.delimiter.field) {\n                // If we reach the end of the CSV and the current character is a field delimiter\n                // Parse the previously seen value and add it to the line\n                const parsedValue = csv.substring(stateVariables.startIndex, index);\n                splitLine.push(parsedValue);\n                // Then add an empty string to the line since the last character being a field delimiter indicates an empty field\n                splitLine.push('');\n                lines.push(splitLine);\n            }\n            else if (index === lastCharacterIndex || nextNChar === options.delimiter.eol &&\n                // if we aren't inside wrap delimiters or if we are but the character before was a wrap delimiter and we didn't just see two\n                (!stateVariables.insideWrapDelimiter ||\n                    stateVariables.insideWrapDelimiter && charBefore === options.delimiter.wrap && !stateVariables.justParsedDoubleQuote)) {\n                // Otherwise if we reached the end of the line or csv (and current character is not a field delimiter)\n                const toIndex = index !== lastCharacterIndex || charBefore === options.delimiter.wrap ? index : undefined;\n                // Retrieve the remaining value and add it to the split line list of values\n                splitLine.push(csv.substring(stateVariables.startIndex, toIndex));\n                // Finally, push the split line values into the lines array and clear the split line\n                lines.push(splitLine);\n                splitLine = [];\n                stateVariables.startIndex = index + eolDelimiterLength;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;\n            }\n            else if (character === options.delimiter.wrap && charBefore === options.delimiter.field &&\n                !stateVariables.insideWrapDelimiter && !stateVariables.parsingValue) {\n                // If we reached a wrap delimiter after a comma and we aren't inside a wrap delimiter\n                stateVariables.startIndex = index;\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                // If the next character(s) are an EOL delimiter, then skip them so we don't parse what we've seen as another value\n                if (utils.getNCharacters(csv, index + 1, eolDelimiterLength) === options.delimiter.eol) {\n                    index += options.delimiter.eol.length + 1; // Skip past EOL\n                }\n            }\n            else if ((charBefore !== options.delimiter.wrap || stateVariables.justParsedDoubleQuote && charBefore === options.delimiter.wrap) &&\n                character === options.delimiter.wrap && utils.getNCharacters(csv, index + 1, eolDelimiterLength) === options.delimiter.eol) {\n                // If we reach a wrap which is not preceded by a wrap delim and the next character is an EOL delim (ie. *\"\\n)\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = false;\n                // Next iteration will substring, add the value to the line, and push the line onto the array of lines\n            }\n            else if (character === options.delimiter.wrap && (index === 0 || utils.getNCharacters(csv, index - eolDelimiterLength, eolDelimiterLength) === options.delimiter.eol && !stateVariables.insideWrapDelimiter)) {\n                // If the line starts with a wrap delimiter (ie. \"*)\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index;\n            }\n            else if (character === options.delimiter.wrap && charAfter === options.delimiter.field) {\n                // If we reached a wrap delimiter with a field delimiter after it (ie. *\",)\n                splitLine.push(csv.substring(stateVariables.startIndex, index + 1));\n                stateVariables.startIndex = index + 2; // next value starts after the field delimiter\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = false;\n            }\n            else if (character === options.delimiter.wrap && charBefore === options.delimiter.field &&\n                !stateVariables.insideWrapDelimiter && stateVariables.parsingValue) {\n                // If we reached a wrap delimiter with a field delimiter after it (ie. ,\"*)\n                splitLine.push(csv.substring(stateVariables.startIndex, index - 1));\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index;\n            }\n            else if (character === options.delimiter.wrap && charAfter === options.delimiter.wrap && index !== stateVariables.startIndex) {\n                // If we run into an escaped quote (ie. \"\") skip past the second quote\n                index += 2;\n                stateVariables.justParsedDoubleQuote = true;\n                continue;\n            }\n            else if (character === options.delimiter.field && charBefore !== options.delimiter.wrap &&\n                charAfter !== options.delimiter.wrap && !stateVariables.insideWrapDelimiter &&\n                stateVariables.parsingValue) {\n                // If we reached a field delimiter and are not inside the wrap delimiters (ie. *,*)\n                splitLine.push(csv.substring(stateVariables.startIndex, index));\n                stateVariables.startIndex = index + 1;\n            }\n            else if (character === options.delimiter.field && charBefore === options.delimiter.wrap &&\n                charAfter !== options.delimiter.wrap && !stateVariables.parsingValue) {\n                // If we reached a field delimiter, the previous character was a wrap delimiter, and the\n                //   next character is not a wrap delimiter (ie. \",*)\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index + 1;\n            }\n            // Otherwise increment to the next character\n            index++;\n            // Reset the double quote state variable\n            stateVariables.justParsedDoubleQuote = false;\n        }\n        return lines;\n    }\n    /**\n     * Retrieves the record lines from the split CSV lines and sets it on the params object\n     */\n    function retrieveRecordLines(params) {\n        if (options.headerFields) { // This option is passed for instances where the CSV has no header line\n            params.recordLines = params.lines;\n        }\n        else { // All lines except for the header line\n            params.recordLines = params.lines.splice(1);\n        }\n        return params;\n    }\n    /**\n     * Retrieves the value for the record from the line at the provided key.\n     */\n    function retrieveRecordValueFromLine(headerField, line) {\n        // If there is a value at the key's index, use it; otherwise, null\n        const value = line[headerField.index];\n        // Perform any necessary value conversions on the record value\n        return processRecordValue(value);\n    }\n    /**\n     * Processes the record's value by parsing the data to ensure the CSV is\n     * converted to the JSON that created it.\n     */\n    function processRecordValue(fieldValue) {\n        // If the value is an array representation, convert it\n        const parsedJson = parseValue(fieldValue);\n        // If parsedJson is anything aside from an error, then we want to use the parsed value\n        // This allows us to interpret values like 'null' --> null, 'false' --> false\n        if (!utils.isError(parsedJson) && !utils.isInvalid(parsedJson)) {\n            return parsedJson;\n        }\n        else if (fieldValue === 'undefined') {\n            return undefined;\n        }\n        return fieldValue;\n    }\n    /**\n     * Trims the record value, if specified by the user via the options object\n     */\n    function trimRecordValue(fieldValue) {\n        if (options.trimFieldValues && fieldValue !== null) {\n            return fieldValue.trim();\n        }\n        return fieldValue;\n    }\n    /**\n     * Create a JSON document with the given keys (designated by the CSV header)\n     *   and the values (from the given line)\n     * @returns {Object} created json document\n     */\n    function createDocument(headerFields, line) {\n        // Reduce the keys into a JSON document representing the given line\n        return headerFields.reduce((document, headerField) => {\n            // If there is a value at the key's index in the line, set the value; otherwise null\n            const value = retrieveRecordValueFromLine(headerField, line);\n            try {\n                // Otherwise add the key and value to the document\n                return (0, doc_path_1.setPath)(document, headerField.value, value);\n            }\n            catch (error) {\n                // Catch any errors where key paths are null or '' and continue\n                return document;\n            }\n        }, {});\n    }\n    /**\n     * Removes the outermost wrap delimiters from a value, if they are present\n     * Otherwise, the non-wrapped value is returned as is\n     */\n    function removeWrapDelimitersFromValue(fieldValue) {\n        const firstChar = fieldValue[0], lastIndex = fieldValue.length - 1, lastChar = fieldValue[lastIndex];\n        // If the field starts and ends with a wrap delimiter\n        if (firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap) {\n            return fieldValue.substr(1, lastIndex - 1);\n        }\n        return fieldValue;\n    }\n    /**\n     * Unescapes wrap delimiters by replacing duplicates with a single (eg. \"\" -> \")\n     * This is done in order to parse RFC 4180 compliant CSV back to JSON\n     */\n    function unescapeWrapDelimiterInField(fieldValue) {\n        return fieldValue.replace(escapedWrapDelimiterRegex, options.delimiter.wrap);\n    }\n    /**\n     * Main helper function to convert the CSV to the JSON document array\n     */\n    function transformRecordLines(params) {\n        // For each line, create the document and add it to the array of documents\n        return params.recordLines.reduce((generatedJsonObjects, line) => {\n            line = line.map((fieldValue) => {\n                // Perform the necessary operations on each line\n                fieldValue = removeWrapDelimitersFromValue(fieldValue);\n                fieldValue = unescapeWrapDelimiterInField(fieldValue);\n                fieldValue = trimRecordValue(fieldValue);\n                return fieldValue;\n            });\n            const generatedDocument = createDocument(params.headerFields, line);\n            return generatedJsonObjects.concat(generatedDocument);\n        }, []);\n    }\n    /**\n     * Attempts to parse the provided value. If it is not parsable, then an error is returned\n     */\n    function parseValue(value) {\n        try {\n            if (utils.isStringRepresentation(value, options) && !utils.isDateRepresentation(value)) {\n                return value;\n            }\n            const parsedJson = valueParserFn(value);\n            // If the parsed value is an array, then we also need to trim record values, if specified\n            if (Array.isArray(parsedJson)) {\n                return parsedJson.map(trimRecordValue);\n            }\n            return parsedJson;\n        }\n        catch (err) {\n            return err;\n        }\n    }\n    /**\n     * Internally exported csv2json function\n     */\n    function convert(data) {\n        // Split the CSV into lines using the specified EOL option\n        const stripped = stripExcelBOM(data);\n        const split = splitLines(stripped);\n        const heading = retrieveHeading(split); // Retrieve the headings from the CSV, unless the user specified the keys\n        const lines = retrieveRecordLines(heading); // Retrieve the record lines from the CSV\n        return transformRecordLines(lines); // Retrieve the JSON document array\n    }\n    return {\n        convert,\n    };\n};\nexports.Csv2Json = Csv2Json;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}