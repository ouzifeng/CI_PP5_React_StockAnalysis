{"ast":null,"code":"/**\n * @license MIT\n * doc-path <https://github.com/mrodrig/doc-path>\n * Copyright (c) 2015-present, Michael Rodrigues.\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setPath = exports.evaluatePath = void 0;\n/**\n * Main function that evaluates the path in a particular object\n * @throws {Error} possible error if call stack size is exceeded\n */\nfunction evaluatePath(obj, kp) {\n  if (!obj) {\n    return null;\n  }\n  const {\n    dotIndex,\n    key,\n    remaining\n  } = state(kp);\n  const kpVal = typeof obj === 'object' && kp in obj ? obj[kp] : undefined;\n  const keyVal = typeof obj === 'object' && key in obj ? obj[key] : undefined;\n  // If there is a '.' in the key path and the key path doesn't appear in the object, recur on the subobject\n  if (dotIndex >= 0 && typeof obj === 'object' && !(kp in obj)) {\n    // If there's an array at the current key in the object, then iterate over those items evaluating the remaining path\n    if (Array.isArray(keyVal)) {\n      return keyVal.map(doc => evaluatePath(doc, remaining));\n    }\n    // Otherwise, we can just recur\n    return evaluatePath(keyVal, remaining);\n  } else if (Array.isArray(obj)) {\n    // If this object is actually an array, then iterate over those items evaluating the path\n    return obj.map(doc => evaluatePath(doc, kp));\n  } else if (dotIndex >= 0 && kp !== key && typeof obj === 'object' && key in obj) {\n    // If there's a field with a non-nested dot, then recur into that sub-value\n    return evaluatePath(keyVal, remaining);\n  } else if (dotIndex === -1 && typeof obj === 'object' && key in obj && !(kp in obj)) {\n    // If the field is here, but the key was escaped\n    return keyVal;\n  }\n  // Otherwise, we can just return value directly\n  return kpVal;\n}\nexports.evaluatePath = evaluatePath;\n/**\n * Main function that performs validation before passing off to _sp\n * @throws {Error} possible error if call stack size is exceeded\n */\nfunction setPath(obj, kp, v) {\n  if (!obj) {\n    throw new Error('No object was provided.');\n  } else if (!kp) {\n    throw new Error('No keyPath was provided.');\n  }\n  return _sp(obj, kp, v);\n}\nexports.setPath = setPath;\n// Helper function that will set the value in the provided object/array.\nfunction _sp(obj, kp, v) {\n  const {\n    dotIndex,\n    key,\n    remaining\n  } = state(kp);\n  // If this is clearly a prototype pollution attempt, then refuse to modify the path\n  if (kp.startsWith('__proto__') || kp.startsWith('constructor') || kp.startsWith('prototype')) {\n    return obj;\n  }\n  if (dotIndex >= 0) {\n    // If there is a '.' in the key path, recur on the subdoc and ...\n    if (typeof obj === 'object' && obj !== null && !(key in obj) && Array.isArray(obj)) {\n      // If this is an array and there are multiple levels of keys to iterate over, recur.\n      obj.forEach(doc => _sp(doc, kp, v));\n      return obj;\n    } else if (typeof obj === 'object' && obj !== null && !(key in obj) && !Array.isArray(obj)) {\n      // If the current key doesn't exist yet, populate it\n      obj[key] = {};\n    }\n    _sp(obj[key], remaining, v);\n  } else if (Array.isArray(obj)) {\n    // If this \"obj\" is actually an array, then we can loop over each of the values and set the path\n    obj.forEach(doc => _sp(doc, remaining, v));\n    return obj;\n  } else {\n    // Otherwise, we can set the path directly\n    obj[key] = v;\n  }\n  return obj;\n}\n// Helper function that returns some information necessary to evaluate or set a path  based on the provided keyPath value\nfunction state(kp) {\n  const dotIndex = findFirstNonEscapedDotIndex(kp);\n  return {\n    dotIndex,\n    key: kp.slice(0, dotIndex >= 0 ? dotIndex : undefined).replace(/\\\\./g, '.'),\n    remaining: kp.slice(dotIndex + 1)\n  };\n}\nfunction findFirstNonEscapedDotIndex(kp) {\n  for (let i = 0; i < kp.length; i++) {\n    const previousChar = i > 0 ? kp[i - 1] : '',\n      currentChar = kp[i];\n    if (currentChar === '.' && previousChar !== '\\\\') return i;\n  }\n  return -1;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","setPath","evaluatePath","obj","kp","dotIndex","key","remaining","state","kpVal","undefined","keyVal","Array","isArray","map","doc","v","Error","_sp","startsWith","forEach","findFirstNonEscapedDotIndex","slice","replace","i","length","previousChar","currentChar"],"sources":["C:/Users/David/Desktop/Websites/stocks/frontend/node_modules/doc-path/lib/path.js"],"sourcesContent":["/**\n * @license MIT\n * doc-path <https://github.com/mrodrig/doc-path>\n * Copyright (c) 2015-present, Michael Rodrigues.\n */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setPath = exports.evaluatePath = void 0;\n/**\n * Main function that evaluates the path in a particular object\n * @throws {Error} possible error if call stack size is exceeded\n */\nfunction evaluatePath(obj, kp) {\n    if (!obj) {\n        return null;\n    }\n    const { dotIndex, key, remaining } = state(kp);\n    const kpVal = typeof obj === 'object' && kp in obj ? obj[kp] : undefined;\n    const keyVal = typeof obj === 'object' && key in obj ? obj[key] : undefined;\n    // If there is a '.' in the key path and the key path doesn't appear in the object, recur on the subobject\n    if (dotIndex >= 0 && typeof obj === 'object' && !(kp in obj)) {\n        // If there's an array at the current key in the object, then iterate over those items evaluating the remaining path\n        if (Array.isArray(keyVal)) {\n            return keyVal.map((doc) => evaluatePath(doc, remaining));\n        }\n        // Otherwise, we can just recur\n        return evaluatePath(keyVal, remaining);\n    }\n    else if (Array.isArray(obj)) {\n        // If this object is actually an array, then iterate over those items evaluating the path\n        return obj.map((doc) => evaluatePath(doc, kp));\n    }\n    else if (dotIndex >= 0 && kp !== key && typeof obj === 'object' && key in obj) {\n        // If there's a field with a non-nested dot, then recur into that sub-value\n        return evaluatePath(keyVal, remaining);\n    }\n    else if (dotIndex === -1 && typeof obj === 'object' && key in obj && !(kp in obj)) {\n        // If the field is here, but the key was escaped\n        return keyVal;\n    }\n    // Otherwise, we can just return value directly\n    return kpVal;\n}\nexports.evaluatePath = evaluatePath;\n/**\n * Main function that performs validation before passing off to _sp\n * @throws {Error} possible error if call stack size is exceeded\n */\nfunction setPath(obj, kp, v) {\n    if (!obj) {\n        throw new Error('No object was provided.');\n    }\n    else if (!kp) {\n        throw new Error('No keyPath was provided.');\n    }\n    return _sp(obj, kp, v);\n}\nexports.setPath = setPath;\n// Helper function that will set the value in the provided object/array.\nfunction _sp(obj, kp, v) {\n    const { dotIndex, key, remaining } = state(kp);\n    // If this is clearly a prototype pollution attempt, then refuse to modify the path\n    if (kp.startsWith('__proto__') || kp.startsWith('constructor') || kp.startsWith('prototype')) {\n        return obj;\n    }\n    if (dotIndex >= 0) {\n        // If there is a '.' in the key path, recur on the subdoc and ...\n        if (typeof obj === 'object' && obj !== null && !(key in obj) && Array.isArray(obj)) {\n            // If this is an array and there are multiple levels of keys to iterate over, recur.\n            obj.forEach((doc) => _sp(doc, kp, v));\n            return obj;\n        }\n        else if (typeof obj === 'object' && obj !== null && !(key in obj) && !Array.isArray(obj)) {\n            // If the current key doesn't exist yet, populate it\n            obj[key] = {};\n        }\n        _sp(obj[key], remaining, v);\n    }\n    else if (Array.isArray(obj)) {\n        // If this \"obj\" is actually an array, then we can loop over each of the values and set the path\n        obj.forEach((doc) => _sp(doc, remaining, v));\n        return obj;\n    }\n    else {\n        // Otherwise, we can set the path directly\n        obj[key] = v;\n    }\n    return obj;\n}\n// Helper function that returns some information necessary to evaluate or set a path  based on the provided keyPath value\nfunction state(kp) {\n    const dotIndex = findFirstNonEscapedDotIndex(kp);\n    return {\n        dotIndex,\n        key: kp.slice(0, dotIndex >= 0 ? dotIndex : undefined).replace(/\\\\./g, '.'),\n        remaining: kp.slice(dotIndex + 1)\n    };\n}\nfunction findFirstNonEscapedDotIndex(kp) {\n    for (let i = 0; i < kp.length; i++) {\n        const previousChar = i > 0 ? kp[i - 1] : '', currentChar = kp[i];\n        if (currentChar === '.' && previousChar !== '\\\\')\n            return i;\n    }\n    return -1;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}