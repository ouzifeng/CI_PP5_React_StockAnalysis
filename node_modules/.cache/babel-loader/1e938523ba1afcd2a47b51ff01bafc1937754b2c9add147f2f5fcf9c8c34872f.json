{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isInvalid = exports.flatten = exports.unique = exports.arrayDifference = exports.isError = exports.isUndefined = exports.isNull = exports.isObject = exports.isString = exports.isNumber = exports.unwind = exports.getNCharacters = exports.removeEmptyFields = exports.isEmptyField = exports.computeSchemaDifferences = exports.isDateRepresentation = exports.isStringRepresentation = exports.deepCopy = exports.validate = exports.buildC2JOptions = exports.buildJ2COptions = void 0;\nconst doc_path_1 = require(\"doc-path\");\nconst constants_1 = require(\"./constants\");\nconst dateStringRegex = /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z/,\n  MAX_ARRAY_LENGTH = 100000;\n/**\n * Build the options to be passed to the appropriate function\n * If a user does not provide custom options, then we use our default\n * If options are provided, then we set each valid key that was passed\n */\nfunction buildJ2COptions(opts) {\n  return {\n    ...constants_1.defaultJson2CsvOptions,\n    ...opts,\n    delimiter: {\n      field: opts?.delimiter?.field ?? constants_1.defaultJson2CsvOptions.delimiter.field,\n      wrap: opts?.delimiter?.wrap || constants_1.defaultJson2CsvOptions.delimiter.wrap,\n      eol: opts?.delimiter?.eol || constants_1.defaultJson2CsvOptions.delimiter.eol\n    },\n    fieldTitleMap: Object.create({})\n  };\n}\nexports.buildJ2COptions = buildJ2COptions;\n/**\n * Build the options to be passed to the appropriate function\n * If a user does not provide custom options, then we use our default\n * If options are provided, then we set each valid key that was passed\n */\nfunction buildC2JOptions(opts) {\n  return {\n    ...constants_1.defaultCsv2JsonOptions,\n    ...opts,\n    delimiter: {\n      field: opts?.delimiter?.field ?? constants_1.defaultCsv2JsonOptions.delimiter.field,\n      wrap: opts?.delimiter?.wrap || constants_1.defaultCsv2JsonOptions.delimiter.wrap,\n      eol: opts?.delimiter?.eol || constants_1.defaultCsv2JsonOptions.delimiter.eol\n    }\n  };\n}\nexports.buildC2JOptions = buildC2JOptions;\nfunction validate(data, validationFn, errorMessages) {\n  if (!data) throw new Error(`${errorMessages.cannotCallOn} ${data}.`);\n  if (!validationFn(data)) throw new Error(errorMessages.dataCheckFailure);\n  return true;\n}\nexports.validate = validate;\n/**\n * Utility function to deep copy an object, used by the module tests\n */\nfunction deepCopy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\nexports.deepCopy = deepCopy;\n/**\n * Helper function that determines whether the provided value is a representation\n *   of a string. Given the RFC4180 requirements, that means that the value is\n *   wrapped in value wrap delimiters (usually a quotation mark on each side).\n */\nfunction isStringRepresentation(fieldValue, options) {\n  const firstChar = fieldValue[0],\n    lastIndex = fieldValue.length - 1,\n    lastChar = fieldValue[lastIndex];\n  // If the field starts and ends with a wrap delimiter\n  return firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap;\n}\nexports.isStringRepresentation = isStringRepresentation;\n/**\n * Helper function that determines whether the provided value is a representation\n *   of a date.\n */\nfunction isDateRepresentation(fieldValue) {\n  return dateStringRegex.test(fieldValue);\n}\nexports.isDateRepresentation = isDateRepresentation;\n/**\n * Helper function that determines the schema differences between two objects.\n */\nfunction computeSchemaDifferences(schemaA, schemaB) {\n  return arrayDifference(schemaA, schemaB).concat(arrayDifference(schemaB, schemaA));\n}\nexports.computeSchemaDifferences = computeSchemaDifferences;\n/**\n * Utility function to check if a field is considered empty so that the emptyFieldValue can be used instead\n */\nfunction isEmptyField(fieldValue) {\n  return isUndefined(fieldValue) || isNull(fieldValue) || fieldValue === '';\n}\nexports.isEmptyField = isEmptyField;\n/**\n * Helper function that removes empty field values from an array.\n */\nfunction removeEmptyFields(fields) {\n  return fields.filter(field => !isEmptyField(field));\n}\nexports.removeEmptyFields = removeEmptyFields;\n/**\n * Helper function that retrieves the next n characters from the start index in\n *   the string including the character at the start index. This is used to\n *   check if are currently at an EOL value, since it could be multiple\n *   characters in length (eg. '\\r\\n')\n */\nfunction getNCharacters(str, start, n) {\n  return str.substring(start, start + n);\n}\nexports.getNCharacters = getNCharacters;\n/**\n * The following unwind functionality is a heavily modified version of @edwincen's\n * unwind extension for lodash. Since lodash is a large package to require in,\n * and all of the required functionality was already being imported, either\n * natively or with doc-path, I decided to rewrite the majority of the logic\n * so that an additional dependency would not be required. The original code\n * with the lodash dependency can be found here:\n *\n * https://github.com/edwincen/unwind/blob/master/index.js\n */\n/**\n * Core function that unwinds an item at the provided path\n */\nfunction unwindItem(accumulator, item, fieldPath) {\n  const valueToUnwind = (0, doc_path_1.evaluatePath)(item, fieldPath);\n  let cloned = deepCopy(item);\n  if (Array.isArray(valueToUnwind) && valueToUnwind.length) {\n    valueToUnwind.forEach(val => {\n      cloned = deepCopy(item);\n      accumulator.push((0, doc_path_1.setPath)(cloned, fieldPath, val));\n    });\n  } else if (Array.isArray(valueToUnwind) && valueToUnwind.length === 0) {\n    // Push an empty string so the value is empty since there are no values\n    (0, doc_path_1.setPath)(cloned, fieldPath, '');\n    accumulator.push(cloned);\n  } else {\n    accumulator.push(cloned);\n  }\n}\n/**\n * Main unwind function which takes an array and a field to unwind.\n */\nfunction unwind(array, field) {\n  const result = [];\n  array.forEach(item => {\n    unwindItem(result, item, field);\n  });\n  return result;\n}\nexports.unwind = unwind;\n/**\n * Checks whether value can be converted to a number\n */\nfunction isNumber(value) {\n  return !isNaN(Number(value));\n}\nexports.isNumber = isNumber;\n/*\n * Helper functions which were created to remove underscorejs from this package.\n */\nfunction isString(value) {\n  return typeof value === 'string';\n}\nexports.isString = isString;\nfunction isObject(value) {\n  return typeof value === 'object';\n}\nexports.isObject = isObject;\nfunction isNull(value) {\n  return value === null;\n}\nexports.isNull = isNull;\nfunction isUndefined(value) {\n  return typeof value === 'undefined';\n}\nexports.isUndefined = isUndefined;\nfunction isError(value) {\n  // TODO(mrodrig): test this possible change\n  // return value instanceof Error;\n  return Object.prototype.toString.call(value) === '[object Error]';\n}\nexports.isError = isError;\nfunction arrayDifference(a, b) {\n  return a.filter(x => !b.includes(x));\n}\nexports.arrayDifference = arrayDifference;\nfunction unique(array) {\n  return [...new Set(array)];\n}\nexports.unique = unique;\nfunction flatten(array) {\n  // Node 11+ - use the native array flattening function\n  if (array.flat) {\n    return array.flat();\n  }\n  // #167 - allow browsers to flatten very long 200k+ element arrays\n  if (array.length > MAX_ARRAY_LENGTH) {\n    let safeArray = [];\n    for (let a = 0; a < array.length; a += MAX_ARRAY_LENGTH) {\n      safeArray = safeArray.concat(...array.slice(a, a + MAX_ARRAY_LENGTH));\n    }\n    return safeArray;\n  }\n  return array.reduce((accumulator, value) => accumulator.concat(value), []);\n}\nexports.flatten = flatten;\n/**\n * Used to help avoid incorrect values returned by JSON.parse when converting\n * CSV back to JSON, such as '39e1804' which JSON.parse converts to Infinity\n */\nfunction isInvalid(parsedJson) {\n  return parsedJson === Infinity || parsedJson === -Infinity;\n}\nexports.isInvalid = isInvalid;","map":{"version":3,"names":["Object","defineProperty","exports","value","isInvalid","flatten","unique","arrayDifference","isError","isUndefined","isNull","isObject","isString","isNumber","unwind","getNCharacters","removeEmptyFields","isEmptyField","computeSchemaDifferences","isDateRepresentation","isStringRepresentation","deepCopy","validate","buildC2JOptions","buildJ2COptions","doc_path_1","require","constants_1","dateStringRegex","MAX_ARRAY_LENGTH","opts","defaultJson2CsvOptions","delimiter","field","wrap","eol","fieldTitleMap","create","defaultCsv2JsonOptions","data","validationFn","errorMessages","Error","cannotCallOn","dataCheckFailure","obj","JSON","parse","stringify","fieldValue","options","firstChar","lastIndex","length","lastChar","test","schemaA","schemaB","concat","fields","filter","str","start","n","substring","unwindItem","accumulator","item","fieldPath","valueToUnwind","evaluatePath","cloned","Array","isArray","forEach","val","push","setPath","array","result","isNaN","Number","prototype","toString","call","a","b","x","includes","Set","flat","safeArray","slice","reduce","parsedJson","Infinity"],"sources":["C:/Users/David/Desktop/Websites/stocks/frontend/node_modules/json-2-csv/lib/utils.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isInvalid = exports.flatten = exports.unique = exports.arrayDifference = exports.isError = exports.isUndefined = exports.isNull = exports.isObject = exports.isString = exports.isNumber = exports.unwind = exports.getNCharacters = exports.removeEmptyFields = exports.isEmptyField = exports.computeSchemaDifferences = exports.isDateRepresentation = exports.isStringRepresentation = exports.deepCopy = exports.validate = exports.buildC2JOptions = exports.buildJ2COptions = void 0;\nconst doc_path_1 = require(\"doc-path\");\nconst constants_1 = require(\"./constants\");\nconst dateStringRegex = /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z/, MAX_ARRAY_LENGTH = 100000;\n/**\n * Build the options to be passed to the appropriate function\n * If a user does not provide custom options, then we use our default\n * If options are provided, then we set each valid key that was passed\n */\nfunction buildJ2COptions(opts) {\n    return {\n        ...constants_1.defaultJson2CsvOptions,\n        ...opts,\n        delimiter: {\n            field: opts?.delimiter?.field ?? constants_1.defaultJson2CsvOptions.delimiter.field,\n            wrap: opts?.delimiter?.wrap || constants_1.defaultJson2CsvOptions.delimiter.wrap,\n            eol: opts?.delimiter?.eol || constants_1.defaultJson2CsvOptions.delimiter.eol,\n        },\n        fieldTitleMap: Object.create({}),\n    };\n}\nexports.buildJ2COptions = buildJ2COptions;\n/**\n * Build the options to be passed to the appropriate function\n * If a user does not provide custom options, then we use our default\n * If options are provided, then we set each valid key that was passed\n */\nfunction buildC2JOptions(opts) {\n    return {\n        ...constants_1.defaultCsv2JsonOptions,\n        ...opts,\n        delimiter: {\n            field: opts?.delimiter?.field ?? constants_1.defaultCsv2JsonOptions.delimiter.field,\n            wrap: opts?.delimiter?.wrap || constants_1.defaultCsv2JsonOptions.delimiter.wrap,\n            eol: opts?.delimiter?.eol || constants_1.defaultCsv2JsonOptions.delimiter.eol,\n        },\n    };\n}\nexports.buildC2JOptions = buildC2JOptions;\nfunction validate(data, validationFn, errorMessages) {\n    if (!data)\n        throw new Error(`${errorMessages.cannotCallOn} ${data}.`);\n    if (!validationFn(data))\n        throw new Error(errorMessages.dataCheckFailure);\n    return true;\n}\nexports.validate = validate;\n/**\n * Utility function to deep copy an object, used by the module tests\n */\nfunction deepCopy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nexports.deepCopy = deepCopy;\n/**\n * Helper function that determines whether the provided value is a representation\n *   of a string. Given the RFC4180 requirements, that means that the value is\n *   wrapped in value wrap delimiters (usually a quotation mark on each side).\n */\nfunction isStringRepresentation(fieldValue, options) {\n    const firstChar = fieldValue[0], lastIndex = fieldValue.length - 1, lastChar = fieldValue[lastIndex];\n    // If the field starts and ends with a wrap delimiter\n    return firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap;\n}\nexports.isStringRepresentation = isStringRepresentation;\n/**\n * Helper function that determines whether the provided value is a representation\n *   of a date.\n */\nfunction isDateRepresentation(fieldValue) {\n    return dateStringRegex.test(fieldValue);\n}\nexports.isDateRepresentation = isDateRepresentation;\n/**\n * Helper function that determines the schema differences between two objects.\n */\nfunction computeSchemaDifferences(schemaA, schemaB) {\n    return arrayDifference(schemaA, schemaB)\n        .concat(arrayDifference(schemaB, schemaA));\n}\nexports.computeSchemaDifferences = computeSchemaDifferences;\n/**\n * Utility function to check if a field is considered empty so that the emptyFieldValue can be used instead\n */\nfunction isEmptyField(fieldValue) {\n    return isUndefined(fieldValue) || isNull(fieldValue) || fieldValue === '';\n}\nexports.isEmptyField = isEmptyField;\n/**\n * Helper function that removes empty field values from an array.\n */\nfunction removeEmptyFields(fields) {\n    return fields.filter((field) => !isEmptyField(field));\n}\nexports.removeEmptyFields = removeEmptyFields;\n/**\n * Helper function that retrieves the next n characters from the start index in\n *   the string including the character at the start index. This is used to\n *   check if are currently at an EOL value, since it could be multiple\n *   characters in length (eg. '\\r\\n')\n */\nfunction getNCharacters(str, start, n) {\n    return str.substring(start, start + n);\n}\nexports.getNCharacters = getNCharacters;\n/**\n * The following unwind functionality is a heavily modified version of @edwincen's\n * unwind extension for lodash. Since lodash is a large package to require in,\n * and all of the required functionality was already being imported, either\n * natively or with doc-path, I decided to rewrite the majority of the logic\n * so that an additional dependency would not be required. The original code\n * with the lodash dependency can be found here:\n *\n * https://github.com/edwincen/unwind/blob/master/index.js\n */\n/**\n * Core function that unwinds an item at the provided path\n */\nfunction unwindItem(accumulator, item, fieldPath) {\n    const valueToUnwind = (0, doc_path_1.evaluatePath)(item, fieldPath);\n    let cloned = deepCopy(item);\n    if (Array.isArray(valueToUnwind) && valueToUnwind.length) {\n        valueToUnwind.forEach((val) => {\n            cloned = deepCopy(item);\n            accumulator.push((0, doc_path_1.setPath)(cloned, fieldPath, val));\n        });\n    }\n    else if (Array.isArray(valueToUnwind) && valueToUnwind.length === 0) {\n        // Push an empty string so the value is empty since there are no values\n        (0, doc_path_1.setPath)(cloned, fieldPath, '');\n        accumulator.push(cloned);\n    }\n    else {\n        accumulator.push(cloned);\n    }\n}\n/**\n * Main unwind function which takes an array and a field to unwind.\n */\nfunction unwind(array, field) {\n    const result = [];\n    array.forEach((item) => {\n        unwindItem(result, item, field);\n    });\n    return result;\n}\nexports.unwind = unwind;\n/**\n * Checks whether value can be converted to a number\n */\nfunction isNumber(value) {\n    return !isNaN(Number(value));\n}\nexports.isNumber = isNumber;\n/*\n * Helper functions which were created to remove underscorejs from this package.\n */\nfunction isString(value) {\n    return typeof value === 'string';\n}\nexports.isString = isString;\nfunction isObject(value) {\n    return typeof value === 'object';\n}\nexports.isObject = isObject;\nfunction isNull(value) {\n    return value === null;\n}\nexports.isNull = isNull;\nfunction isUndefined(value) {\n    return typeof value === 'undefined';\n}\nexports.isUndefined = isUndefined;\nfunction isError(value) {\n    // TODO(mrodrig): test this possible change\n    // return value instanceof Error;\n    return Object.prototype.toString.call(value) === '[object Error]';\n}\nexports.isError = isError;\nfunction arrayDifference(a, b) {\n    return a.filter((x) => !b.includes(x));\n}\nexports.arrayDifference = arrayDifference;\nfunction unique(array) {\n    return [...new Set(array)];\n}\nexports.unique = unique;\nfunction flatten(array) {\n    // Node 11+ - use the native array flattening function\n    if (array.flat) {\n        return array.flat();\n    }\n    // #167 - allow browsers to flatten very long 200k+ element arrays\n    if (array.length > MAX_ARRAY_LENGTH) {\n        let safeArray = [];\n        for (let a = 0; a < array.length; a += MAX_ARRAY_LENGTH) {\n            safeArray = safeArray.concat(...array.slice(a, a + MAX_ARRAY_LENGTH));\n        }\n        return safeArray;\n    }\n    return array.reduce((accumulator, value) => accumulator.concat(value), []);\n}\nexports.flatten = flatten;\n/**\n * Used to help avoid incorrect values returned by JSON.parse when converting\n * CSV back to JSON, such as '39e1804' which JSON.parse converts to Infinity\n */\nfunction isInvalid(parsedJson) {\n    return parsedJson === Infinity ||\n        parsedJson === -Infinity;\n}\nexports.isInvalid = isInvalid;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}